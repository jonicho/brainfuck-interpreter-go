package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
)

var programScanner *bufio.Scanner
var data []byte
var dataPtr uint16
var stdinReader *bufio.Reader
var program *instruction

type instructionType int

const (
	nop instructionType = iota
	move
	add
	print
	read
	loop
	clear
)

type instruction struct {
	instructionType instructionType
	value           uint16
	offset          uint16
	next            *instruction
	loop            *instruction
}

func parseProgram() *instruction {
	firstInstruction := &instruction{instructionType: nop}
	currentInstruction := firstInstruction
	for currentInstruction != nil && programScanner.Scan() {
		nextInstruction := &instruction{offset: 0, value: 1}
		switch programScanner.Text() {
		case "<":
			nextInstruction.value = math.MaxUint16 // -1
			fallthrough
		case ">":
			nextInstruction.instructionType = move
		case "-":
			nextInstruction.value = math.MaxUint16 // -1
			fallthrough
		case "+":
			nextInstruction.instructionType = add
		case ".":
			nextInstruction.instructionType = print
		case ",":
			nextInstruction.instructionType = read
		case "[":
			nextInstruction.instructionType = loop
			nextInstruction.loop = parseProgram()
		case "]":
			nextInstruction = nil
		}
		currentInstruction.next = nextInstruction
		currentInstruction = nextInstruction
	}
	return firstInstruction
}

func runInstruction(instruction *instruction) {
	for instruction != nil {
		switch instruction.instructionType {
		case nop:
		case move:
			dataPtr += instruction.value
		case add:
			data[dataPtr+instruction.offset] += byte(instruction.value)
		case print:
			fmt.Printf("%c", data[dataPtr+instruction.offset])
		case read:
			data[dataPtr+instruction.offset], _ = stdinReader.ReadByte()
		case loop:
			for data[dataPtr] != 0 {
				runInstruction(instruction.loop)
			}
		case clear:
			data[dataPtr+instruction.offset] = 0
		}
		instruction = instruction.next
	}
}

func removeNops(instruction *instruction) *instruction {
	if instruction == nil {
		return nil
	}
	switch instruction.instructionType {
	case nop:
		return removeNops(instruction.next)
	case loop:
		instruction.loop = removeNops(instruction.loop)
		fallthrough
	default:
		instruction.next = removeNops(instruction.next)
		return instruction
	}
}

func optimizeAdjacentInstructions(instruction *instruction) {
	if instruction == nil {
		return
	}
	switch instruction.instructionType {
	case move, add:
		for instruction.next != nil && instruction.next.instructionType == instruction.instructionType && instruction.next.offset == instruction.offset {
			instruction.value += instruction.next.value
			instruction.next = instruction.next.next
		}
	case loop:
		optimizeAdjacentInstructions(instruction.loop)
	}
	optimizeAdjacentInstructions(instruction.next)
}

func optimizeClearLoops(instruction *instruction) {
	if instruction == nil {
		return
	}
	optimizeClearLoops(instruction.next)
	if instruction.instructionType == loop {
		if instruction.loop != nil && instruction.loop.instructionType == add && instruction.loop.next == nil {
			instruction.instructionType = clear
			instruction.loop = nil
		} else {
			optimizeClearLoops(instruction.loop)
		}
	}
}

func optimizeOffsets(inst *instruction) {
	if inst == nil {
		return
	}
	currentInstruction := inst
	var offset uint16 = 0
	for currentInstruction != nil && currentInstruction.instructionType != loop {
		if currentInstruction.instructionType == move {
			offset += currentInstruction.value
			currentInstruction.instructionType = nop
		} else {
			currentInstruction.offset = offset
		}
		if currentInstruction.next == nil || currentInstruction.next.instructionType == loop {
			break
		}
		currentInstruction = currentInstruction.next
	}
	if offset != 0 {
		currentInstruction.next = &instruction{instructionType: move, value: offset, next: currentInstruction.next}
		currentInstruction = currentInstruction.next
	}
	if currentInstruction != nil {
		optimizeOffsets(currentInstruction.next)
		if currentInstruction.instructionType == loop {
			optimizeOffsets(currentInstruction.loop)
		}
	}
}

func optimizeProgram() {
	program = removeNops(program)
	optimizeAdjacentInstructions(program)
	optimizeClearLoops(program)
	optimizeOffsets(program)
	program = removeNops(program) // remove nops generated by optimizeOffsets
}

func main() {
	args := os.Args
	if len(args) < 2 {
		fmt.Printf("Usage: %s file\n", args[0])
		os.Exit(0)
	}

	programFile, err := os.Open(os.Args[1])
	if err != nil {
		fmt.Printf("Failed to open file!\n")
		os.Exit(1)
	}
	programScanner = bufio.NewScanner(programFile)
	programScanner.Split(bufio.ScanRunes)
	program = parseProgram()

	optimizeProgram()

	data = make([]byte, math.MaxUint16+1)
	stdinReader = bufio.NewReader(os.Stdin)
	runInstruction(program)
}
